// Code generated by protoc-gen-go. DO NOT EDIT.
// source: login_guide/login_guide.proto

package userlogin

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// The request message containing the user's name.
type LoginRequest struct {
	UserId               string   `protobuf:"bytes,1,opt,name=userId,proto3" json:"userId,omitempty"`
	Password             string   `protobuf:"bytes,2,opt,name=password,proto3" json:"password,omitempty"`
	DeviceId             string   `protobuf:"bytes,3,opt,name=deviceId,proto3" json:"deviceId,omitempty"`
	Onece                string   `protobuf:"bytes,4,opt,name=onece,proto3" json:"onece,omitempty"`
	Signature            string   `protobuf:"bytes,5,opt,name=signature,proto3" json:"signature,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LoginRequest) Reset()         { *m = LoginRequest{} }
func (m *LoginRequest) String() string { return proto.CompactTextString(m) }
func (*LoginRequest) ProtoMessage()    {}
func (*LoginRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_297f1529e65767ff, []int{0}
}

func (m *LoginRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_LoginRequest.Unmarshal(m, b)
}
func (m *LoginRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_LoginRequest.Marshal(b, m, deterministic)
}
func (m *LoginRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LoginRequest.Merge(m, src)
}
func (m *LoginRequest) XXX_Size() int {
	return xxx_messageInfo_LoginRequest.Size(m)
}
func (m *LoginRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_LoginRequest.DiscardUnknown(m)
}

var xxx_messageInfo_LoginRequest proto.InternalMessageInfo

func (m *LoginRequest) GetUserId() string {
	if m != nil {
		return m.UserId
	}
	return ""
}

func (m *LoginRequest) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

func (m *LoginRequest) GetDeviceId() string {
	if m != nil {
		return m.DeviceId
	}
	return ""
}

func (m *LoginRequest) GetOnece() string {
	if m != nil {
		return m.Onece
	}
	return ""
}

func (m *LoginRequest) GetSignature() string {
	if m != nil {
		return m.Signature
	}
	return ""
}

type TokenReply struct {
	Token                string   `protobuf:"bytes,1,opt,name=token,proto3" json:"token,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TokenReply) Reset()         { *m = TokenReply{} }
func (m *TokenReply) String() string { return proto.CompactTextString(m) }
func (*TokenReply) ProtoMessage()    {}
func (*TokenReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_297f1529e65767ff, []int{1}
}

func (m *TokenReply) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TokenReply.Unmarshal(m, b)
}
func (m *TokenReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TokenReply.Marshal(b, m, deterministic)
}
func (m *TokenReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TokenReply.Merge(m, src)
}
func (m *TokenReply) XXX_Size() int {
	return xxx_messageInfo_TokenReply.Size(m)
}
func (m *TokenReply) XXX_DiscardUnknown() {
	xxx_messageInfo_TokenReply.DiscardUnknown(m)
}

var xxx_messageInfo_TokenReply proto.InternalMessageInfo

func (m *TokenReply) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

type TokenCheckRequest struct {
	Token                string   `protobuf:"bytes,1,opt,name=token,proto3" json:"token,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TokenCheckRequest) Reset()         { *m = TokenCheckRequest{} }
func (m *TokenCheckRequest) String() string { return proto.CompactTextString(m) }
func (*TokenCheckRequest) ProtoMessage()    {}
func (*TokenCheckRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_297f1529e65767ff, []int{2}
}

func (m *TokenCheckRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TokenCheckRequest.Unmarshal(m, b)
}
func (m *TokenCheckRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TokenCheckRequest.Marshal(b, m, deterministic)
}
func (m *TokenCheckRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TokenCheckRequest.Merge(m, src)
}
func (m *TokenCheckRequest) XXX_Size() int {
	return xxx_messageInfo_TokenCheckRequest.Size(m)
}
func (m *TokenCheckRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_TokenCheckRequest.DiscardUnknown(m)
}

var xxx_messageInfo_TokenCheckRequest proto.InternalMessageInfo

func (m *TokenCheckRequest) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

type TokenCheckReply struct {
	Flag                 int32    `protobuf:"varint,1,opt,name=flag,proto3" json:"flag,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TokenCheckReply) Reset()         { *m = TokenCheckReply{} }
func (m *TokenCheckReply) String() string { return proto.CompactTextString(m) }
func (*TokenCheckReply) ProtoMessage()    {}
func (*TokenCheckReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_297f1529e65767ff, []int{3}
}

func (m *TokenCheckReply) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TokenCheckReply.Unmarshal(m, b)
}
func (m *TokenCheckReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TokenCheckReply.Marshal(b, m, deterministic)
}
func (m *TokenCheckReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TokenCheckReply.Merge(m, src)
}
func (m *TokenCheckReply) XXX_Size() int {
	return xxx_messageInfo_TokenCheckReply.Size(m)
}
func (m *TokenCheckReply) XXX_DiscardUnknown() {
	xxx_messageInfo_TokenCheckReply.DiscardUnknown(m)
}

var xxx_messageInfo_TokenCheckReply proto.InternalMessageInfo

func (m *TokenCheckReply) GetFlag() int32 {
	if m != nil {
		return m.Flag
	}
	return 0
}

func init() {
	proto.RegisterType((*LoginRequest)(nil), "userlogin.LoginRequest")
	proto.RegisterType((*TokenReply)(nil), "userlogin.TokenReply")
	proto.RegisterType((*TokenCheckRequest)(nil), "userlogin.TokenCheckRequest")
	proto.RegisterType((*TokenCheckReply)(nil), "userlogin.TokenCheckReply")
}

func init() {
	proto.RegisterFile("login_guide/login_guide.proto", fileDescriptor_297f1529e65767ff)
}

var fileDescriptor_297f1529e65767ff = []byte{
	// 303 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x92, 0x4f, 0x4b, 0xc3, 0x40,
	0x10, 0xc5, 0x5d, 0x6d, 0xaa, 0x19, 0x2a, 0xc5, 0xc5, 0x3f, 0x21, 0x54, 0x90, 0x80, 0x50, 0x2f,
	0x51, 0xea, 0x59, 0x10, 0x3c, 0xd4, 0x82, 0xa7, 0xa8, 0xe0, 0x4d, 0x62, 0x32, 0xc6, 0xd0, 0x98,
	0x8d, 0xbb, 0x1b, 0xc5, 0xaf, 0xe1, 0x67, 0xf3, 0x03, 0xc9, 0x4e, 0x92, 0x76, 0x11, 0xbd, 0xe8,
	0x6d, 0xde, 0xfc, 0x5e, 0x1e, 0x6f, 0x87, 0xc0, 0x7e, 0x21, 0xb2, 0xbc, 0xbc, 0xcf, 0xea, 0x3c,
	0xc5, 0x63, 0x6b, 0x0e, 0x2b, 0x29, 0xb4, 0xe0, 0x6e, 0xad, 0x50, 0xd2, 0x3a, 0xf8, 0x60, 0x30,
	0xb8, 0x32, 0x53, 0x84, 0x2f, 0x35, 0x2a, 0xcd, 0x77, 0xa1, 0x6f, 0xe8, 0x2c, 0xf5, 0xd8, 0x01,
	0x1b, 0xbb, 0x51, 0xab, 0xb8, 0x0f, 0x1b, 0x55, 0xac, 0xd4, 0x9b, 0x90, 0xa9, 0xb7, 0x4a, 0x64,
	0xa1, 0x0d, 0x4b, 0xf1, 0x35, 0x4f, 0x70, 0x96, 0x7a, 0x6b, 0x0d, 0xeb, 0x34, 0xdf, 0x06, 0x47,
	0x94, 0x98, 0xa0, 0xd7, 0x23, 0xd0, 0x08, 0x3e, 0x02, 0x57, 0xe5, 0x59, 0x19, 0xeb, 0x5a, 0xa2,
	0xe7, 0x10, 0x59, 0x2e, 0x82, 0x00, 0xe0, 0x46, 0xcc, 0xb1, 0x8c, 0xb0, 0x2a, 0xde, 0x4d, 0x82,
	0x36, 0xaa, 0x2d, 0xd4, 0x88, 0xe0, 0x08, 0xb6, 0xc8, 0x73, 0xf1, 0x84, 0xc9, 0xbc, 0x2b, 0xff,
	0xb3, 0xf5, 0x10, 0x86, 0xb6, 0xd5, 0x64, 0x72, 0xe8, 0x3d, 0x16, 0x71, 0x46, 0x3e, 0x27, 0xa2,
	0x79, 0xf2, 0xc9, 0x60, 0x7d, 0x2a, 0x11, 0x35, 0x4a, 0x7e, 0x0e, 0x83, 0x5b, 0x85, 0x32, 0xc2,
	0x2c, 0x57, 0x46, 0xef, 0x85, 0x8b, 0x93, 0x85, 0xf6, 0xb9, 0xfc, 0x1d, 0x0b, 0x2c, 0x3b, 0x07,
	0x2b, 0xfc, 0x0c, 0x5c, 0x93, 0x40, 0xe6, 0x3f, 0x7c, 0x7e, 0xd9, 0x9e, 0x80, 0x3a, 0xf3, 0xd1,
	0x77, 0x9b, 0xfd, 0x6a, 0xdf, 0xff, 0x85, 0x52, 0xd2, 0xe4, 0x0e, 0x36, 0xaf, 0xb5, 0xc4, 0xf8,
	0xb9, 0x7b, 0xdb, 0x14, 0x86, 0xcd, 0xe2, 0x1f, 0xfd, 0xc6, 0xec, 0x84, 0x3d, 0xf4, 0xe9, 0x6f,
	0x3a, 0xfd, 0x0a, 0x00, 0x00, 0xff, 0xff, 0x0a, 0x39, 0x79, 0xe1, 0x6e, 0x02, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConnInterface

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion6

// GreeterClient is the client API for Greeter service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type GreeterClient interface {
	// Sends a greeting
	UserRegister(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*TokenReply, error)
	UserLogin(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*TokenReply, error)
	TokenCheck(ctx context.Context, in *TokenCheckRequest, opts ...grpc.CallOption) (*TokenCheckReply, error)
}

type greeterClient struct {
	cc grpc.ClientConnInterface
}

func NewGreeterClient(cc grpc.ClientConnInterface) GreeterClient {
	return &greeterClient{cc}
}

func (c *greeterClient) UserRegister(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*TokenReply, error) {
	out := new(TokenReply)
	err := c.cc.Invoke(ctx, "/userlogin.Greeter/UserRegister", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *greeterClient) UserLogin(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*TokenReply, error) {
	out := new(TokenReply)
	err := c.cc.Invoke(ctx, "/userlogin.Greeter/UserLogin", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *greeterClient) TokenCheck(ctx context.Context, in *TokenCheckRequest, opts ...grpc.CallOption) (*TokenCheckReply, error) {
	out := new(TokenCheckReply)
	err := c.cc.Invoke(ctx, "/userlogin.Greeter/TokenCheck", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// GreeterServer is the server API for Greeter service.
type GreeterServer interface {
	// Sends a greeting
	UserRegister(context.Context, *LoginRequest) (*TokenReply, error)
	UserLogin(context.Context, *LoginRequest) (*TokenReply, error)
	TokenCheck(context.Context, *TokenCheckRequest) (*TokenCheckReply, error)
}

// UnimplementedGreeterServer can be embedded to have forward compatible implementations.
type UnimplementedGreeterServer struct {
}

func (*UnimplementedGreeterServer) UserRegister(ctx context.Context, req *LoginRequest) (*TokenReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserRegister not implemented")
}
func (*UnimplementedGreeterServer) UserLogin(ctx context.Context, req *LoginRequest) (*TokenReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserLogin not implemented")
}
func (*UnimplementedGreeterServer) TokenCheck(ctx context.Context, req *TokenCheckRequest) (*TokenCheckReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TokenCheck not implemented")
}

func RegisterGreeterServer(s *grpc.Server, srv GreeterServer) {
	s.RegisterService(&_Greeter_serviceDesc, srv)
}

func _Greeter_UserRegister_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoginRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GreeterServer).UserRegister(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/userlogin.Greeter/UserRegister",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GreeterServer).UserRegister(ctx, req.(*LoginRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Greeter_UserLogin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoginRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GreeterServer).UserLogin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/userlogin.Greeter/UserLogin",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GreeterServer).UserLogin(ctx, req.(*LoginRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Greeter_TokenCheck_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TokenCheckRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GreeterServer).TokenCheck(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/userlogin.Greeter/TokenCheck",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GreeterServer).TokenCheck(ctx, req.(*TokenCheckRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Greeter_serviceDesc = grpc.ServiceDesc{
	ServiceName: "userlogin.Greeter",
	HandlerType: (*GreeterServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "UserRegister",
			Handler:    _Greeter_UserRegister_Handler,
		},
		{
			MethodName: "UserLogin",
			Handler:    _Greeter_UserLogin_Handler,
		},
		{
			MethodName: "TokenCheck",
			Handler:    _Greeter_TokenCheck_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "login_guide/login_guide.proto",
}

// StreamGreeterClient is the client API for StreamGreeter service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type StreamGreeterClient interface {
	StreamUserLogin(ctx context.Context, opts ...grpc.CallOption) (StreamGreeter_StreamUserLoginClient, error)
}

type streamGreeterClient struct {
	cc grpc.ClientConnInterface
}

func NewStreamGreeterClient(cc grpc.ClientConnInterface) StreamGreeterClient {
	return &streamGreeterClient{cc}
}

func (c *streamGreeterClient) StreamUserLogin(ctx context.Context, opts ...grpc.CallOption) (StreamGreeter_StreamUserLoginClient, error) {
	stream, err := c.cc.NewStream(ctx, &_StreamGreeter_serviceDesc.Streams[0], "/userlogin.StreamGreeter/StreamUserLogin", opts...)
	if err != nil {
		return nil, err
	}
	x := &streamGreeterStreamUserLoginClient{stream}
	return x, nil
}

type StreamGreeter_StreamUserLoginClient interface {
	Send(*LoginRequest) error
	Recv() (*TokenReply, error)
	grpc.ClientStream
}

type streamGreeterStreamUserLoginClient struct {
	grpc.ClientStream
}

func (x *streamGreeterStreamUserLoginClient) Send(m *LoginRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *streamGreeterStreamUserLoginClient) Recv() (*TokenReply, error) {
	m := new(TokenReply)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// StreamGreeterServer is the server API for StreamGreeter service.
type StreamGreeterServer interface {
	StreamUserLogin(StreamGreeter_StreamUserLoginServer) error
}

// UnimplementedStreamGreeterServer can be embedded to have forward compatible implementations.
type UnimplementedStreamGreeterServer struct {
}

func (*UnimplementedStreamGreeterServer) StreamUserLogin(srv StreamGreeter_StreamUserLoginServer) error {
	return status.Errorf(codes.Unimplemented, "method StreamUserLogin not implemented")
}

func RegisterStreamGreeterServer(s *grpc.Server, srv StreamGreeterServer) {
	s.RegisterService(&_StreamGreeter_serviceDesc, srv)
}

func _StreamGreeter_StreamUserLogin_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(StreamGreeterServer).StreamUserLogin(&streamGreeterStreamUserLoginServer{stream})
}

type StreamGreeter_StreamUserLoginServer interface {
	Send(*TokenReply) error
	Recv() (*LoginRequest, error)
	grpc.ServerStream
}

type streamGreeterStreamUserLoginServer struct {
	grpc.ServerStream
}

func (x *streamGreeterStreamUserLoginServer) Send(m *TokenReply) error {
	return x.ServerStream.SendMsg(m)
}

func (x *streamGreeterStreamUserLoginServer) Recv() (*LoginRequest, error) {
	m := new(LoginRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _StreamGreeter_serviceDesc = grpc.ServiceDesc{
	ServiceName: "userlogin.StreamGreeter",
	HandlerType: (*StreamGreeterServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamUserLogin",
			Handler:       _StreamGreeter_StreamUserLogin_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "login_guide/login_guide.proto",
}
